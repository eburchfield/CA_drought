}
b ~ dnorm(0,0.0001)
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif(0,100)
for (j in 1:n.counties){
a[j] ~ dnorm(mu.a, tau.a)
}
mu.a ~ dnorm(0,0.0001)
tau.a <- pow(sigma.a, -2)
sigma.a ~ dunif(0,100)}"
predictor.inits <- function(chain){
seed <- jg.seeds [(100 + chain) %% length (jg.seeds) + 1]
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
jags.seeds
help(cumsum())
help(cumsum)
help(c)
help("par")
predictor.inits <- function(chain){
seed <- jags.seeds [(100 + chain) %% length (jags.seeds) + 1]  #jg seeds???
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
library(rjags)
predictor.inits <- function(chain){
seed <- jags.seeds [(100 + chain) %% length (jags.seeds) + 1]  #jg seeds???
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
mlm.ses.nopred
summary(mlm.ses.npored)
summary(mlm.ses.nopred)
help(pow)
??pow
rnorm(n.counties)
n
mlm.ses.nopred
summary(mlm.ses.nopred)
post.nopred
summary(post.nopred)
mean.a.nopred
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.radon.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
predictor.inits <- function(chain){
seed <- jg.seeds [(100 + chain) %% length (jg.seeds) + 1]  #jg seeds???
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.radon.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
model_string_pred <- "model {
for (i in 1:n){
y[i] ~ dnorm (y.hat[i], tau.y)
y.hat[i] <- a[county[i]] + b*pos[i]
}
b ~ dnorm(0,0.0001)
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif(0,100)
for (j in 1:n.counties){
a[j] ~ dnorm(mu.a, tau.a)
}
mu.a ~ dnorm(0,0.0001)
tau.a <- pow(sigma.a, -2)
sigma.a ~ dunif(0,100)}"
#################function chain?  jg.seeds##########################
predictor.inits <- function(chain){
seed <- jg.seeds [(100 + chain) %% length (jg.seeds) + 1]  #jg seeds???
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.radon.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
#jags with individual level predictor
#####instead of a only, y now includes effect of pos in mean estimate
#county level info does not change.
model_string_pred <- "model {
for (i in 1:n){
y[i] ~ dnorm (y.hat[i], tau.y)
y.hat[i] <- a[county[i]] + b*pos[i]
}
b ~ dnorm(0,0.0001)
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif(0,100)
for (j in 1:n.counties){
a[j] ~ dnorm(mu.a, tau.a)
}
mu.a ~ dnorm(0,0.0001)
tau.a <- pow(sigma.a, -2)
sigma.a ~ dunif(0,100)}"
#################function chain?  jg.seeds##########################
predictor.inits <- function(chain){
seed <- jg.seeds [(100 + chain) %% length (jg.seeds) + 1]  #jg seeds???
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1)
)
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
?power
#discuss results from#
summary(mlm.ses.nopred)
library(ggmcmc)
g = ggs(mlm.ses.nopred)
ggs_traceplot(g)
ggs_autocorrelation(g)
ggs_crosscorrelation(g)
ggs_histogram(g)
ggs_Rhat(g)
ggs_traceplot(g)
ggs_geweke(g)
predictor.inits <- function(chain){
list (a=rnorm( n.counties ), b=rnorm(1),
mu.a= rnorm(1), sigma.y=runif(1), sigma.a=runif(1))
}
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
library(rjags)
library(coda)
ses.pred.data <-  list(n=n, n.counties=n.counties, y=y,
county=county, pos=pos)
ses.pred.parameters <- c("a", "b", "mu.a", "sigma.y", "sigma.a")
mlm.ses.pred.model <- jags.model(textConnection(model_string_pred),
data = ses.pred.data,
inits = predictor.inits,
n.chains = 3,
n.adapt=1000)
update(mlm.ses.pred.model, niter=2000)
mlm.radon.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
#extract useful data
post.pred <- as.matrix(mlm.ses.pred)
alphavarvar <- mean(post.pred[, 'mu.a'])
mean.a.pred <- rep(NA, n.counties)
sd.a.pred <- rep(NA,n.counties)
for (i in 1:n.counties) {
mean.a.pred[i] <- mean(post.pred[ ,paste('a[',i,']', sel='')])
sd.a.pred[i] <- sd(post.pred[] ,paste('a[',i,']', sel='')]))
}
#extract useful data
post.pred <- as.matrix(mlm.ses.pred)
alphavarvar <- mean(post.pred[, 'mu.a'])
mean.a.pred <- rep(NA, n.counties)
sd.a.pred <- rep(NA,n.counties)
for (i in 1:n.counties) {
mean.a.pred[i] <- mean(post.pred[ ,paste('a[',i,']', sel='')])
sd.a.pred[i] <- sd(post.pred[ ,paste('a[',i,']', sel='')]))
}
#extract useful data
post.pred <- as.matrix(mlm.ses.pred)
alphavarvar <- mean(post.pred[, 'mu.a'])
mean.a.pred <- rep(NA, n.counties)
sd.a.pred <- rep(NA,n.counties)
for (i in 1:n.counties) {
mean.a.pred[i] <- mean(post.pred[ ,paste('a[',i,']', sel='')])
sd.a.pred[i] <- sd(post.pred[ ,paste('a[',i,']', sel='')])
}
mlm.radon.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
#extract useful data
post.pred <- as.matrix(mlm.ses.pred)
alphavarvar <- mean(post.pred[, 'mu.a'])
post.pred <- as.matrix(mlm.ses.pred)
mlm.ses.pred <- coda.samples(mlm.ses.pred.model, variable.names = ses.pred.parameters,
n.iter = 2000)
#extract useful data
post.pred <- as.matrix(mlm.ses.pred)
alphavarvar <- mean(post.pred[, 'mu.a'])
mean.a.pred <- rep(NA, n.counties)
sd.a.pred <- rep(NA,n.counties)
#syn
for (i in 1:n.counties) {
mean.a.pred[i] <- mean(post.pred[ ,paste('a[',i,']', sel='')])
sd.a.pred[i] <- sd(post.pred[ ,paste('a[',i,']', sel='')])
}
names(post.pred)
colnames(post.pred)
for (i in 1:n.counties) {
mean.a.pred[i] <- mean(post.pred[ ,paste('a[',i,']', sep='')])
sd.a.pred[i] <- sd(post.pred[ ,paste('a[',i,']', sep='')])
}
dim(post.pred)
typeof(mydata)
class(mydata)
table(ses)
table(pos)
summary(mydata)
??sum
help(sum)
source('C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Dissertation/Method/Bayes/Kruschke code/BernGrid.R')
nIntervals = 10
rm(list = ls())
source('C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Dissertation/Method/Bayes/Kruschke code/BernGrid.R')
nIntervals = 10
width = 1/nIntervals
Theta = seq(from = width/2, to = 1-width/2, by = width)
width
approxMass = dbeta(Theta, 8, 4) * width
approxMass
pTheta = approxMass/sum(approxMass)
pTheta
sum(approxMass)
pTheta = c(50:1, rep(1,50),)
pTheta = c(50:1, rep(1,50), 1:50, 50:1)
pTheta
pTheta = pTheta/sum(pTheta)
pTheta
width = 1/length(pTheta)
Theta = seq(from = width/2, to 1-width/2, by=width)
Theta = seq(from = width/2, to= 1-width/2, by=width)
Theta
width
Data = (c(15,1), c(5,0))
Data = (c(15,1)  c(5,0))
Data = c(15,1), c(5,0)
Data = c(rep(1,15),rep(0,5))
BernGrid(Theta, pTheta, Data)
Theta
plot(Theta)
pTheta = c(50:1, rep(1,50), 1:50, 50:1)
pTheta
plot(pTheta)
pTheta = c(50:1, rep(1,50), 1:50, 50:1, rep(1,50), 1:50)
plot(pTheta)
pTheta = c(50:1, rep(1,50), 1:50, 50:1, rep(1,50), 1:50)
pTheta = pTheta/sum(pTheta)
width = 1/length(pTheta)
Theta = seq(from=width/2, to=1-width/2, by=width)
post = BernGrid(Theta, pTheta, Data)
Data = c(rep(3,1),rep(1,1))
post = BernGrid(Theta, pTheta, Data)
Data
Data = c(rep(1,3),rep(1,1))
post = BernGrid(Theta, pTheta, Data)
Data
Data = c(rep(1,3),rep(0,1))
post = BernGrid(Theta, pTheta, Data)
post2 = BernGrid(Theta, post, c(rep(1,12),rep(0,4)))
post2 = BernGrid(Theta, pTheta = post, c(rep(1,12),rep(0,4)))
post
post = BernGrid(Theta, pTheta, Data)
post2 = BernGrid(Theta, pTheta = post, c(rep(1,12),rep(0,4)))
rm(list = ls())
if ( ! require (rjags )) stop ("Could not load rjags")
if ( ! require (lme4 )) stop ("Could not load lme4")
if ( ! require (ggplot2 )) stop ("Could not load ggplot2")
if ( ! require (ggmcmc )) stop ("Could not load ggmcmc")
if ( ! require (stringr )) stop ("Could not load stringr")
if ( ! require (xtable )) stop ("Could not load xtable")
if ( ! require (BEST )) stop ("Could not load BEST")
if ( ! require(foreign)) stop ("Could not load foreign")
d = "C:\\Users\\Emily Burchfield\\Box Sync\\WF\\Survey\\SEADS HH Pilot Cohort_for emily.sav"
#missing data at the end dropped for now (up to 278)
mydata <- read.spss(d, to.data.frame=T)
ses <- mydata$SESIndex_3[0:278]
position <- mydata$LAN2B.1[0:278]
pos <- addNA(position)
GN <- mydata$HIQ1_CODE[0:278]
table(GN)
source('C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Dissertation/Method/Bayes/Kruschke code/BernMetropolisTemplate.R')
install.packages("BRugs")
library(BRugs)
install.packages("BRugs")
library(BRugs)
library(BRugs)
Agricultural and climatic systems in California's San Joaquin Valley are quite different from those in Sri Lanka.  The San Joaquin Valley covers 9.7 million acres which are home to over 1.6 million people (CAWater_SJHR).  The primary crops cultivated in the area are grapes, walnuts, almonds, and cherries (CDFA, 2013).  Many of the agricultural fields in the valley receive water from surface water irrigation systems (cite).  Heavy pumping of groundwater also provides a significant amount of agricultural water in the region (Cite).  The climate in the valley is Mediterranean, with moderate temperatures throughout the year.  This region of California is home to one of the most productive agricultural systems int he world (cite).  Annual gross production in the valley is more than $25 billion dollars (EPA, 2013).  The average farmsize is 162 acres, signficantly larger than the small plots held by Sri Lankan farmers (CAwaterSJHR).  We have selected these two regions of the world because of the signficiatn differences in crops cultivated, field size and climate.  By testing our models in two distinct agro-ecological regions, we increase confidence in the ability of our model to perform across the globe.
Agricultural and climatic systems in California's San Joaquin Valley are quite different from those in Sri Lanka.  The San Joaquin Valley covers 9.7 million acres which are home to over 1.6 million people (CAWaterSJHR).  The primary crops cultivated in the area are grapes, walnuts, almonds, and cherries (CDFA, 2013).  Many of the agricultural fields in the valley receive water from surface water irrigation systems (cite).  Heavy pumping of groundwater also provides a significant amount of agricultural water in the region (Cite).  The climate in the valley is Mediterranean, with moderate temperatures throughout the year.  This region of California is home to one of the most productive agricultural systems int he world (cite).  Annual gross production in the valley is more than $25 billion dollars (EPA, 2013).  The average farmsize is 162 acres, signficantly larger than the small plots held by Sri Lankan farmers (CAwaterSJHR).  We have selected these two regions of the world because of the signficiatn differences in crops cultivated, field size and climate.  By testing our models in two distinct agro-ecological regions, we increase confidence in the ability of our model to perform across the globe.
install.packages("pandoc")
dnorm(0,.0001)
dnorm(0,.0001)
dnorm(0,.0001)
help(dnorm)
help(pow)
warning("Figure(s) ", paste(missingFig, sep=", "), " with label(s) '",
setwd("C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Kate_Emily/EKB_Code")
library(memisc)
library(dplyr)
require(ggplot2)
require(rjags)
require(ggmcmc)
require(BEST)
require(foreign)
require(shinystan)
dsf <- tbl_df(read.csv("C:\\Users\\Emily Burchfield\\Dropbox\\Vanderbilt\\Kate_Emily\\Data\\pt_data_kn.txt", stringsAsFactors = FALSE))
ds = dsf[dsf$farm_flag==1,]
#change datatype
ds = transform(ds,
tvp_09 = as.numeric(tvp_09),
tvp_14 = as.numeric(tvp_14),
delta_tvp = as.numeric(delta_tvp),
AreaAcres = as.numeric(AreaAcres))
#change values of 999.99 to missing value (Perc_Rip and Perc_Pre1914)
ds[ds==999.99] <- NA
#farming pixels only
df <- ds[ds$farm_flag == 1,]
reomve(ds)
remove(dsf)
#additional variables
df$Rip <- df$COUNT_Rip/df$fmmp_area
df$P1914 <- df$COUNT_Pre1914/df$fmmp_area
#data setup
y <- df$delta_tvp
n <- length(y)
dc.names <- as.vector(df$HUC12)
uq <- unique(dc.names)
n.dc <- length(uq)
dc <- rep(NA, n.dc)
for (i in 1:n.dc){
dc[dc.names == uq[i]] <- i
sample.size <- as.vector(table(dc))
}
library(rbugs)
install.packages("R2WinBUGS")
library(R2WinBUGS)
library(R2WinBUGS)
setwd("C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Kate_Emily/EKB_Code")
library(R2WinBUGS)
library(dplyr)
library(maptools)
dsf <- tbl_df(read.csv("C:\\Users\\Emily Burchfield\\Dropbox\\Vanderbilt\\Kate_Emily\\Data\\pt_data_kn.txt", stringsAsFactors = FALSE))
ds = dsf[dsf$farm_flag==1,]
ds = transform(ds,
tvp_09 = as.numeric(tvp_09),
tvp_14 = as.numeric(tvp_14),
delta_tvp = as.numeric(delta_tvp),
AreaAcres = as.numeric(AreaAcres))
ds[ds==999.99] <- NA
df <- ds[ds$farm_flag == 1,]
remove(ds)
remove(dsf)
ds[ds==999.99] <- NA
df <- ds[ds$farm_flag == 1,]
remove(ds)
remove(dsf)
df$Rip <- df$COUNT_Rip/df$fmmp_area
df$P1914 <- df$COUNT_Pre1914/df$fmmp_area
y <- df$delta_tvp
n <- length(y)
dc.names <- as.vector(df$HUC12)
uq <- unique(dc.names)
n.dc <- length(uq)
dc <- rep(NA, n.dc)
for (i in 1:n.dc){
dc[dc.names == uq[i]] <- i
sample.size <- as.vector(table(dc))
}
grid
df
setwd("C:/Users/Emily Burchfield/Dropbox/Vanderbilt/Kate_Emily/EKB_Code")
library(R2WinBUGS)
library(dplyr)
library(maptools)
dsf <- tbl_df(read.csv("C:\\Users\\Emily Burchfield\\Dropbox\\Vanderbilt\\Kate_Emily\\Data\\pt_data_kn.txt", stringsAsFactors = FALSE))
#ds = dsf[dsf$farm_flag==1,]
dsf = transform(dsf,
tvp_09 = as.numeric(tvp_09),
tvp_14 = as.numeric(tvp_14),
delta_tvp = as.numeric(delta_tvp),
AreaAcres = as.numeric(AreaAcres))
ds[ds==999.99] <- NA
dsf$Rip <- df$COUNT_Rip/df$fmmp_area
dsf$P1914 <- df$COUNT_Pre1914/df$fmmp_area
y <- dsf$delta_tvp
n <- length(y)
dc.names <- as.vector(dsf$HUC12)
uq <- unique(dc.names)
n.dc <- length(uq)
dc <- rep(NA, n.dc)
for (i in 1:n.dc){
dc[dc.names == uq[i]] <- i
sample.size <- as.vector(table(dc))
}
minx <- min(dsf$lon)
maxx <- max(dsf$lon)
miny <- min(dsf$lat)
maxy <- max(dsf$lat)
unique(dsf$lat)
len(unique(dsf$lat))
length(unique(dsf$lat))
length(unique(dsf$lon))
lon <- seq(from = minx, to = maxx, by = row)
lat <- seq(from = miny, to = maxy, by = col)
minx
maxx
miny
maxy
row
row_num = 1155
col_num = 1350
lon <- seq(from = minx, to = maxx, by = row)
lat <- seq(from = miny, to = maxy, by = col)
lon <- seq(from = minx, to = maxx, by = row_num)
lat <- seq(from = miny, to = maxy, by = col_num)
lon
lat
minx
maxx
row_num
lon <- seq(from = minx, to = maxx, by = abs(maxx - minx)/row_num)
lon
len(lon)
length(lon)
xy <- expand.grid(x = dsf$lon, y = dsf$lat)
library(sp)
library(rgdal)
x <- coordinates(dsf$lon)
y <- coordinates(dsf$lat)
xy <- expand.grid(x = x, y = y)
library(maptools)
x <- coordinates(dsf$lon)
y <- coordinates(dsf$lat)
xy <- expand.grid(x = x, y = y)
library(sp)
library(rgdal)
x <- coordinates(dsf$lon)
y <- coordinates(dsf$lat)
lon <- seq(from = minx, to = maxx, by = abs(maxx - minx)/row_num - 1)
lon <- seq(from = minx, to = maxx, by = (abs(maxx - minx)/row_num - 1) )
lon <- seq(from = minx, to = maxx, by = (abs(maxx - minx)/row_num)
)
lat <- seq(from = miny, to = maxy, by = (abs(maxy - miny)/col_num))
xy <- expand.grid(x = dsf$lon, y = dsf$lat)
class(xy)
str(xy)
xy <- expand.grid(x = lon, y = lat)
xy
class(xy)
str(xy)
grid.pts <- SpatialPointsDataFrame(coords = xy, data = xy, proj4string = CRS("+init=epsg:3310") )
gridded(grid.pts) <- TRUE
gridsp <- as (grid.pts, "SpatialPolygons")
shape_nb <- poly2nb(grid.pts)
library(spdep)
shape_nb <- poly2nb(grid.pts)
class(grid.pts)
grid <- SpatialPolygonsDataFrame(grid.pts, data = data.frame(id=row.names(gridsp),
row.names = row.names(gridsp)))
#spedp to compute adjacency mat
fn <- "C:\\Users\\Emily Burchfield\\Dropbox\\Vanderbilt\\Kate_Emily\\Data\\pt_final.shp"
readShapePoly(fn, IDvar = NULL, proj4string = CRS("+init=epsg:3310"),
verbose = F, repair = F, force_ring = F, delete_null_obj = F,
retrieve_ABS_null = F)
